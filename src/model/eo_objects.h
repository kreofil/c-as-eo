#ifndef _eo_objects_
#define _eo_objects_

// Любой объект на C содержит необходимые данные и не более того.
// Обработка данных может вестись внешними функциями

//==============================================================================
// Объявление вспомогательного "любого" объекта,
// используемого в качестве базового типа.
// Физически объект данного типа существовать не должен

// Тэг "любого" объекта
//const int tagAny = 0;

// "Любой" объект
typedef struct eoAny {
  Tag tag;                // уникальный признак внешнего объекта
  struct eoAny* parent;    // указатель на родительский объект
} eoAny;

// Установка признака объекта
void set_tag(eoAny* obj, Tag tag);
// Установка указателя на родительский объект
void set_parent(eoAny* child, eoAny* parent);
// Получение признака объекта
Tag get_tag(eoAny* obj);
// Получение родителя объекта
eoAny* get_parent(eoAny* obj);

//==============================================================================
// Объявление целочисленного атомарного объекта и вложенных в него подобъектов

//------------------------------------------------------------------------------
// Объект, непосредственно вложенный в eoInt, преобразующий число в строку
typedef struct eoIntAsString {
  eoAny base;   // базовая часть для идентификации и связи объектов
  char str[20];
} eoIntAsString;

//------------------------------------------------------------------------------
// Объект, непосредственнов вложенный в eoInt, складывающий два целых
typedef struct eoIntAdd {
  eoAny base;   // базовая часть для идентификации и связи объектов
  struct eoInt* opd2;
} eoIntAdd;

//------------------------------------------------------------------------------
// Объект, непосредственнов вложенный в eoInt, вычитающий для двух целых
typedef struct eoIntSub {
  eoAny base;   // базовая часть для идентификации и связи объектов
  struct eoInt* opd2;
} eoIntSub;

//------------------------------------------------------------------------------
// Объект, непосредственнов вложенный в eoInt, проверяющий на равенство
// Пока реализован в возвратом целочисленного объекта, который в дальнейшем
// предполагается заменить на булевский
typedef struct eoIntEq {
  eoAny base;   // базовая часть для идентификации и связи объектов
  struct eoInt* opd2;
} eoIntEq;

//------------------------------------------------------------------------------
// Объект, непосредственнов вложенный в eoInt, проверяющий на "меньше"
// Пока реализован в возвратом целочисленного объекта, который в дальнейшем
// предполагается заменить на булевский
typedef struct eoIntLess {
  eoAny base;   // базовая часть для идентификации и связи объектов
  struct eoInt* opd2;
} eoIntLess;

// Тэг целочисленного объекта
//const int tagInt = 1;

//------------------------------------------------------------------------------
// Внешний атомарный целочисленный объект
typedef struct eoInt {
  eoAny base;   // базовая часть для идентификации и связи объектов
  int value;
  eoIntAsString asString; // Объект, формирующий строку символов по значению
  eoIntAdd  add;          // Объект, выполняющий сложение
  eoIntSub  sub;          // Объект, выполняющий вычитание
  eoIntAdd  eq;          // Объект, выполняющий сравнение eq
  eoIntSub  less;          // Объект, выполняющий сравнение less
} eoInt;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Функции, осуществляющие работу с целочисленным объектом
// Инициализация существующего целочисленного объекта
void init_eoInt(eoInt* obj, eoAny* parent, int value);
// Установка значения в целочисленном объекте
void set_eoInt_value(eoInt* obj, int value);

// Инициализация объекта add (привязка второго операнда)
void init_eoIntAdd(eoInt* obj, eoInt* opd2);
// Инициализация объекта sub (привязка второго операнда)
void init_eoIntSub(eoInt* obj, eoInt* opd2);
// Инициализация объекта eq (привязка второго операнда)
void init_eoIntEq(eoInt* obj, eoInt* opd2);
// Инициализация объекта less (привязка второго операнда)
void init_eoIntLess(eoInt* obj, eoInt* opd2);

// Получение (датаризация) целочисленного объекта
void get_eoInt(eoAny* obj, eoAny* result);
// Получение (датаризация) строки для целочисленного объекта
void get_eoIntAsString(eoAny* obj, eoAny* result);
// Сложение целочисленного объекта с объектом, привязанным к add
void get_eoIntAdd(eoAny* obj, eoAny* result);
// Вычитание из целочисленного объекта объекта, привязанного к sub
void get_eoIntSub(eoAny* obj, eoAny* result);
// Сравнение eq
void get_eoIntEq(eoAny* obj, eoAny* result);
// Сравнение less
void get_eoIntLess(eoAny* obj, eoAny* result);

//==============================================================================
// Объявление действительного атомарного объекта двойной точности
// и вложенных в него подобъектов

// Объект, непосредственнов вложенный в eoInt
typedef struct eoDoubleAsString {
  eoAny base;   // базовая часть для идентификации и связи объектов
  char str[30];
} eoDoubleAsString;

// Тэг действительного объекта
//const int tagDouble = 2;

// Внешний атомарный действительный объект
typedef struct eoDouble {
  eoAny base;   // базовая часть для идентификации и связи объектов
  double value;
  eoDoubleAsString asString; // Объект, формирующий строку символов по значению
} eoDouble;

// Инициализация существующего действительного объекта
void init_eoDouble(eoDouble* obj, double value);
// Получение (датаризация) действительного объекта
void get_eoDouble(eoAny* obj, eoAny* result);
// Получение (датаризация) строки для действительного объекта
void get_eoDoubleAsString(eoAny* obj, eoAny* result);

//==============================================================================
// Объявление объекта seq, задающего последовательность объектов

//enum { maxSeqsize = 10 };
typedef struct eoSeq {
  eoAny base;   // базовая часть для идентификации и связи объектов
  // Количество объектов в последовательности
  int length;
  // Массив последовательно расположенных объектов.
  // Формируется снаружи и присваивается данному указателю
  eoAny** objSeq;
} eoSeq;

// Инициализация, связана с передачей массива объектов и его размера
void init_eoSeq(eoSeq* obj, eoAny** eoSeq, int length);
// Получение (датаризация) последовательности объектов
void get_eoSeq(eoAny* obj, eoAny* result);

//==============================================================================
// Объявление объекта if и вложенных в него подобъектов

typedef struct eoIf {
  eoAny base;   // базовая часть для идентификации и связи объектов
  // Условие для выбора (пока целочисленный объект, потом булевский)
  eoInt* condition;
  // Объект, определяющий истинную ветку
  eoAny* trueBranch;
  // Объект, определяющий ложную ветку
  eoAny* falseBranch;
} eoIf;

#endif  // _eo_objects_
